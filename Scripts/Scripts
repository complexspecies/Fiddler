import time
import uuid
import requests
from typing import Optional

from django.conf import settings
from django.core.cache import cache


class StandardBankTFIAClient:
    """
    Standard Bank TFIA API client.
    OAuth tokens are cached via django.core.cache.
    """

    TOKEN_EXPIRY_BUFFER_SECONDS = 30

    def __init__(self, timeout: int = 30):
        self.client_id = settings.STB_CLIENT_ID
        self.client_secret = settings.STB_CLIENT_SECRET
        self.auth_token_url = settings.STB_AUTH_TOKEN_URL
        self.api_base_url = settings.STB_API_BASE_URL.rstrip("/")
        self.timeout = timeout

        self.token_cache_key = getattr(
            settings,
            "STB_TOKEN_CACHE_KEY",
            "stb:tfia:access_token",
        )
        self.token_expiry_cache_key = f"{self.token_cache_key}:expiry"

    # ------------------------------------------------------------------
    # Authentication
    # ------------------------------------------------------------------

    def _authenticate(self) -> None:
        payload = {
            "client_id": self.client_id,
            "client_secret": self.client_secret,
            "grant_type": "client_credentials",
        }

        headers = {
            "Content-Type": "application/x-www-form-urlencoded",
            "X-XSRF-Header": "PingFederate",
        }

        response = requests.post(
            self.auth_token_url,
            data=payload,
            headers=headers,
            timeout=self.timeout,
        )
        response.raise_for_status()

        data = response.json()

        access_token = data["access_token"]
        expires_in = int(data["expires_in"])

        # Store absolute expiry timestamp
        expiry_timestamp = (
            int(time.time())
            + expires_in
            - self.TOKEN_EXPIRY_BUFFER_SECONDS
        )

        cache.set(self.token_cache_key, access_token, timeout=expires_in)
        cache.set(self.token_expiry_cache_key, expiry_timestamp, timeout=expires_in)

    def _get_access_token(self) -> str:
        access_token = cache.get(self.token_cache_key)
        expiry_timestamp = cache.get(self.token_expiry_cache_key)

        if not access_token or not expiry_timestamp:
            self._authenticate()
            return cache.get(self.token_cache_key)

        if int(time.time()) >= expiry_timestamp:
            self._authenticate()
            return cache.get(self.token_cache_key)

        return access_token

    # ------------------------------------------------------------------
    # Headers
    # ------------------------------------------------------------------

    def _default_headers(self) -> dict:
        return {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self._get_access_token()}",
            "X-IBM-Client-Id": self.client_id,
            "X-IBM-Client-Secret": self.client_secret,
            "x-fapi-interaction-id": str(uuid.uuid4()),
        }

    # ------------------------------------------------------------------
    # API methods
    # ------------------------------------------------------------------

    def get_contribution_limits(
        self,
        client_id_type: str,
        client_id: str,
        query_date: Optional[str] = None,
    ) -> dict:
        endpoint = "/npextorg/extnonprod/tfia/contribution-limits"

        params = {
            "clientIdType": client_id_type,
            "clientId": client_id,
        }

        if query_date:
            params["queryDate"] = query_date

        url = f"{self.api_base_url}{endpoint}"

        response = requests.get(
            url,
            headers=self._default_headers(),
            params=params,
            timeout=self.timeout,
        )

        # Optional hardening: retry once on 401
        if response.status_code == 401:
            self._authenticate()
            response = requests.get(
                url,
                headers=self._default_headers(),
                params=params,
                timeout=self.timeout,
            )

        response.raise_for_status()
        return response.json()

conn = http.client.HTTPSConnection("api-gatewaynp.standardbank.co.za")
payload = ''
headers = {
    'Content-Type': 'application/json',
    'X-IBM-Client-Id': '30d3651cd4974d13a7840d02be4e5a9c',
    'X-IBM-Client-Secret': '24dBae80FA1F483BA399045A7e440040',
    'x-fapi-interaction-id': str(uuid.uuid4()),
    'Authorization': f'Bearer {data["access_token"]}'
}
path = "/npextorg/extnonprod/tfia/contributions?clientIdType=saxoClientId&clientId=32156854&fromDate=2025-03-01&toDate=2025-03-31"
conn.request("GET", path, payload, headers)
res = conn.getresponse()
data = res.read()
print(data.decode("utf-8"))

example response;
{
    "Data": [
        {
            "ClientId": 32156854,
            "ClientIdType": "saxoClientId",
            "ContributionAccount": "TFIA12345678",
            "ContributionDate": "2025-03-15",
            "ContributionAccountCurrency": "ZAR",
            "ContributionAmount": 5000,
            "ContributionType": "Deposit",
            "ContributionTransactionReference": "REF98765432",
            "ContributionTransactionSource": "Shyft"
        }
    ],
    "Pagination": {
        "Next": "/contributions?clientIdType=saxoClientId&clientId=32156854&fromDate=2025-03-01&toDate=2025-03-31&pageSize=25&pageNumber=2",
        "First": "/contributions?clientIdType=saxoClientId&clientId=32156854&fromDate=2025-03-01&toDate=2025-03-31&pageSize=25&pageNumber=1",
        "Last": "/contributions?clientIdType=saxoClientId&clientId=32156854&fromDate=2025-03-01&toDate=2025-03-31&pageSize=25&pageNumber=4",
        "PageNumber": 1,
        "PageSize": 25,
        "TotalItems": 80,
        "TotalPages": 4,
        "HasNext": true,
        "HasPrevious": false
    }
}


from typing import Optional, Dict, Any
from urllib.parse import urlencode


    def get_contributions(
        self,
        client_id_type: str,
        client_id: str,
        from_date: str,
        to_date: str,
        page_size: int = 25,
        page_number: int = 1,
    ) -> Dict[str, Any]:
        """
        Retrieve paginated contributions and expose pagination
        URLs that refer to THIS API, not the upstream gateway.
        """

        endpoint = "/npextorg/extnonprod/tfia/contributions"

        upstream_params = {
            "clientIdType": client_id_type,
            "clientId": client_id,
            "fromDate": from_date,
            "toDate": to_date,
            "pageSize": page_size,
            "pageNumber": page_number,
        }

        upstream_url = f"{self.api_base_url}{endpoint}"

        response = requests.get(
            upstream_url,
            headers=self._default_headers(),
            params=upstream_params,
            timeout=self.timeout,
        )

        if response.status_code == 401:
            self._authenticate()
            response = requests.get(
                upstream_url,
                headers=self._default_headers(),
                params=upstream_params,
                timeout=self.timeout,
            )

        response.raise_for_status()
        payload = response.json()

        pagination = payload.get("Pagination", {})
        data = payload.get("Data", [])

        total_items = pagination.get("TotalItems", 0)
        has_next = pagination.get("HasNext", False)
        has_previous = pagination.get("HasPrevious", False)

        def _build_public_url(target_page: Optional[int]) -> Optional[str]:
            if not target_page:
                return None

            query = urlencode({
                "clientIdType": client_id_type,
                "clientId": client_id,
                "fromDate": from_date,
                "toDate": to_date,
                "pageSize": page_size,
                "pageNumber": target_page,
            })

            return f"{settings.PUBLIC_API_BASE_URL}/contributions?{query}"

        next_page = page_number + 1 if has_next else None
        previous_page = page_number - 1 if has_previous else None

        return {
            "count": total_items,
            "next": _build_public_url(next_page),
            "previous": _build_public_url(previous_page),
            "data": data,
        }